(** Solving the equations *)

(* This file is part of the ConcurInterproc analyzer, released under GPL license.
   Please read the COPYING file packaged in the distribution.

   Copyright (C) Bertrand Jeannet 2009.
*)

open Format

type var = Syntax.var
type point = Syntax.point

type instrum = {
  mutable isyncond : Syntax.var Bddapron.Syntax.expr;
  mutable icond : Syntax.var Bddapron.Expr2.Bool.t option;
}

type 'a procedure = {
  pname : string;
  (** Procedure name *)
  mutable pinput : Syntax.var Syntax.declaration list;
  (** List of input paramaeters *)
  mutable poutput : Syntax.var Syntax.declaration list;
  (** List of output parameters *)
  mutable pcode : Syntax.var Syntax.block;
  (** Code of the procedure *)
  mutable vars : (Syntax.local, Syntax.var Bddapron.Env.typ) Mappe.t;
  (** Include instrumentation variables *)
  mutable instrumInput : instrum;
  mutable instrumOutput : instrum;
  mutable linput : [`Local of string * string * [`Input]] list;
  mutable loutput : [`Local of string * string * [`Output]] list;
  mutable linputtmp : [`Local of string * string * [`Tmp]] list;
  mutable loutputtmp : [`Local of string * string * [`Tmp]] list;
  mutable linputfrozen : [`Local of string * string * [`InputFrozen]] list;
  mutable linputcst : [`Local of string * string * [`Input | `InputFrozen]] list;
  mutable linputnotcst : [`Local of string * string * [`Input]] list;
  mutable loutputcopy : [`Local of string * string * [`OutputCopy]] list;
  mutable pext : 'a;
}

type ('a,'b) thread = {
  tname : string;
    (** Thread name *)
  tindex  : int;
    (** Thread number *)
  mutable tvars : (Syntax.global, Syntax.var Bddapron.Env.typ) Mappe.t;
    (** Set of global variables (current + possibly input + possibly output) *)
  mutable lglobalinput : [`Global of string * [`Input of string]] list;
  mutable lglobaloutput : [`Global of string * [`Output of string]] list;
  mutable tprocedures : (string,'a procedure) Mappe.t;
    (** Thread procedures *)
  mutable proccallsites : (string, point PSette.t) Hashhe.t;
    (** Association [procedure (name) -> set of callsites] *)
  mutable text : 'b;
}

type ('a,'b) program = {
  mutable typenumdef : (Syntax.var * Syntax.var array) list;
  (** Enumerated types definition. A definition is a pair
      [(name, list of labels)] *)
(*
  mutable global : Syntax.var Syntax.declaration list;
*)
  mutable gvars : (Syntax.global, Syntax.var Bddapron.Env.typ) Mappe.t;
    (** Set of global variables *)
  mutable pcs :  ([`Pc of string], Syntax.var Bddapron.Env.typ) Mappe.t;
    (** Program counters *)
  mutable lglobal : [`Global of string * [`Current]] list;
  mutable lglobaltmp : [`Global of string * [`Tmp]] list;
  mutable initial : Syntax.var Bddapron.Syntax.expr option;
  mutable final : Syntax.var Bddapron.Syntax.expr option;
  mutable lthreads : string list;
  mutable threads : ('a,'b) thread array;
  mutable env : Syntax.var Bddapron.Env.t;
  mutable cond0 : Syntax.var Bddapron.Cond.t;
  startexit : (point,point) PDHashhe.t;
    (** Two-way association start points/exit points of procedures *)
  callret : (point,point) PDHashhe.t;
    (** Two-way association call points/return points generated by
	procedure calls. *)
  pointproc : (point,string) PHashhe.t;
    (** Hashtable [point,name of enclosing procedure/thread] *)
}

let instrum_dummy = {
  isyncond = Syntax.etrue;
  icond = None;
}

let print_instrum fmt instrum =
  fprintf fmt "{@  @[<v>isyncond = %a;@ icond = %a;@]}"
    (Bddapron.Syntax.print_expr Syntax.print_var) instrum.isyncond
    (Print.option Bddapron.Expr2.Bool.print) instrum.icond

let print_instrum2 fmt olvarcond =
  Print.option
    (fun fmt (lvar,cond) ->
      Bddapron.Expr2.Bool.print fmt cond
    )
    fmt
    olvarcond

let print_procedure print_ext fmt proc =
  fprintf fmt "{ @[<v>pname = %s;@ pinput = %a;@ poutput = %a;@ pcode = %a;@ vars = %a;@ instrumInput = %a;@ instrumOutput = %a;@ linput = %a;@ loutput = %a;@ linputtmp = %a;@ loutputtmp = %a;@ linputcst = %a;@ linputnotcst = %a;@ loutputcopy = %a;@ pext=%a@] }"
    proc.pname
    (Syntax.print_declarations Syntax.print_var ~var:false) proc.pinput
    (Syntax.print_declarations Syntax.print_var ~var:false) proc.poutput
    (Syntax.print_block Syntax.print_var Syntax.print_point) proc.pcode
    (Mappe.print Syntax.print_var (Syntax.print_typ Syntax.print_var)) proc.vars
    print_instrum proc.instrumInput
    print_instrum proc.instrumOutput
    (Print.list Syntax.print_var) (proc.linput:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.loutput:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.linputtmp:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.loutputtmp:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.linputcst:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.linputnotcst:>Syntax.var list)
    (Print.list Syntax.print_var) (proc.loutputcopy:>Syntax.var list)
    print_ext proc.pext

let print_thread print_procext print_ext fmt thread =
  fprintf fmt "{ @[<v>tname=%s; tindex=%i;@ tvars=%a;@ lglobalinput=%a;@ lglobaloutput=%a;@ tprocedures=@  %a;@ tcfg = @  %a;@ proccallsites=%a;@] }"
    thread.tname thread.tindex
   (Mappe.print Syntax.print_var (Syntax.print_typ Syntax.print_var)) thread.tvars
    (Print.list Syntax.print_var) (thread.lglobalinput:>Syntax.var list)
    (Print.list Syntax.print_var) (thread.lglobaloutput:>Syntax.var list)
    (Mappe.print pp_print_string (print_procedure print_procext)) thread.tprocedures
    (Hashhe.print pp_print_string (PSette.print Syntax.print_point)) thread.proccallsites
    print_ext thread.text

let print_prog print_procext print_threadext fmt prog =
  fprintf fmt "{ @[<v>gvars=%a;@ lglobal=%a;@ lglobaltmp=%a;@ threads=@  %a;@ startexit=%a;@ callret=%a;@ pointproc=%a;@] }"
    (Mappe.print Syntax.print_var (Syntax.print_typ Syntax.print_var)) prog.gvars
    (Print.list Syntax.print_var) (prog.lglobal:>Syntax.var list)
    (Print.list Syntax.print_var) (prog.lglobaltmp:>Syntax.var list)
    (Print.array (print_thread print_procext print_threadext)) prog.threads
    (PDHashhe.print Syntax.print_point Syntax.print_point) prog.startexit
    (PDHashhe.print Syntax.print_point Syntax.print_point) prog.callret
    (PHashhe.print Syntax.print_point pp_print_string) prog.pointproc

(** Returns the list of instrumentation variables *)
let lvaraux
    (prog:('a,'b) program)
    :
    Syntax.var list
    =
  let res = ref [] in
  Array.iter
    (begin fun thread ->
      Mappe.iter
	(begin fun var _ -> match var with
	| `Global(_,`Current) -> ()
	| _ -> res := (var:>Syntax.var) :: !res
	end)
	thread.tvars
      ;
      Mappe.iter
	(begin fun pname proc ->
	  Mappe.iter
	    (begin fun var _ ->
	      let `Local(t,v,lkind) = var in
	      match lkind with
	      | `Input | `Output | `Local _ -> ()
	      | _ -> res := (var:>Syntax.var) :: !res
	    end)
	    proc.vars
	end)
	thread.tprocedures
    end)
    prog.threads
  ;
  !res
